= Dev Ops on Cloud Foundry Platform

== Goals

To deploy and configure a microservice and UI, leverage the platform for monitoring & management of the microservice, and automate a continuous delivery pipeline.

== Pre-work

1. Fork link:https://github.com/rjain-pivotal/pcf-workshop-workspace/[`PCF Workshop Workspace`]  
2. Review the link:https://github.com/pcf-alliances-immersion/pcf-immersion-workspace/tree/master/cities[overview] of the `cities` repository.  
3. Review the documentation on link:http://docs.pivotal.io/pivotalcf/devguide/deploy-apps/prepare-to-deploy.html[Considerations for Designing and Running an Application in the Cloud]
4. Review the documentation on link:http://docs.pivotal.io/pivotalcf/devguide/deploy-apps/streaming-logs.html#writing[Writing to logs]

== Steps
In this workshop we are going to follow these steps to deploy apps on Cloud foundry and manage the lifecycle
image:blue-green.png[Blue Green Deployment]

=== Building apps
To build the app go to the workspace folder
[source,perl]
cd pcf-workshop-workspace/cities
gradle build

=== Pushing the cities-service app using CLI
[source,bash]
cd pcf-workshop-workspace/cities/cities-service/build/libs



Use `cf help` and/or `cf <command> --help` for details on each of the commands below.

. Review the docs: http://docs.pivotal.io/pivotalcf/devguide/deploy-apps/deploy-app.html

. Verify you are logged in with your own userid (*not admin*) and targeted to your PCF instance:
+
[source,bash]
----
$ cf target
----

. Push the cities-service:
+
[source,bash]
----
$ cf push cities-service -i 1 -m 512M -p cities-service-0.0.1-SNAPSHOT.jar
----
+
* Be sure to name your application '<first-initial><last-initial>-cities-service'

. Verify you can access your application via a curl request:
+
[source,bash]
----
$ curl -i cities-service/cities
----


=== Using Manifests to Push the cities-ui app

Next, push the cities-ui app
Now, use a manifest to help automate deployment.

. Review the documentation: http://docs.pivotal.io/pivotalcf/devguide/deploy-apps/manifest.html

. Create an application manifest in your `cities-service` directory called `manifest.yml`.  Minimally, you must set the name of the app, the amount of memory, the number of instances, and the path to the .jar file.
+
*Be sure to name your application '<first-initial><last-initial>-cities-service' and use this as the host value.*
+
We must be able to access your application at https://<first-initial><last-initial>-cities-service.YOUR_PCF_APP_DOMAIN

. The IBM Bluemix team has created a manifest generator app that can also be used:
+
* Hosted: http://cfmanigen.mybluemix.net/
* Source: https://github.com/IBM-Bluemix/cf-manifest-generator
+

. Test your manifest by re-pushing your app with no parameters:
+
[source,bash]
----
$ cf push
----

=== Dependency Injection in Spring

 Bind to in memory database

=== Health, logging & events via the CLI

 View recent logs using CLI

=== Binding to services

 Bind Cities Services to MySQL
 Bind Cities UI to Cities Services

=== Environment variables

 View the environment variable and explantion of VCAP

=== Scaling apps

 Scale the App using Ops Manager

=== Verify the app from the Console

=== Create Version 2

 Create Version 2 by changing the Version Number Env variable 

=== Push Version 2 and Delete the Old Route using the script
Create a env file with the following variables
[source,bash]
CF_SYSTEM_DOMAIN: the CF system domain
CF_APPS_DOMAIN: the CF apps domain
CF_USER: the user account
CF_ORG: org to deploy to
CF_SPACE: space to deply to
CF_APP: the app name
CF_JAR: path to the jar on jenkins
CF_MANIFEST: path to the manifest on jenkins
CF_PWD: your password

Using the bash script blue-green.sh deploy the green v2 and delete the blue v1 of the app. 

[source,bash]
----

cf login -a https://api.$CF_SYSTEM_DOMAIN <Add the correct flags to include the username, password, org and space> --skip-ssl-validation

DEPLOYED_VERSION_CMD=$(CF_COLOR=false cf apps | grep $CF_APP- | cut -d" " -f1)
DEPLOYED_VERSION="$DEPLOYED_VERSION_CMD"
ROUTE_VERSION=$(echo "${BUILD_NUMBER}" | cut -d"." -f1-3 | tr '.' '-')
echo "Deployed Version: $DEPLOYED_VERSION"
echo "Route Version: $ROUTE_VERSION"

# push a new version and map the route
cf <???> "$CF_APP-$BUILD_NUMBER" -n "$CF_APP-$ROUTE_VERSION" -d $CF_APPS_DOMAIN -p $CF_JAR -f $CF_MANIFEST
cf <???> "$CF_APP-${BUILD_NUMBER}" $CF_APPS_DOMAIN -n $CF_APP

if [ ! -z "$DEPLOYED_VERSION" -a "$DEPLOYED_VERSION" != " " -a "$DEPLOYED_VERSION" != "$CF_APP-${BUILD_NUMBER}" ]; then
  echo "Performing zero-downtime cutover to $BUILD_NUMBER"
  echo "$DEPLOYED_VERSION" | while read line
  do
    if [ ! -z "$line" -a "$line" != " " -a "$line" != "$CF_APP-${BUILD_NUMBER}" ]; then
      echo "Scaling down, unmapping and removing $line"
      # Unmap the route and delete
      cf <???>-route "$line" $CF_APPS_DOMAIN -n $CF_APP
      cf <???> "$line" -f
      cf delete-route $CF_APPS_DOMAIN -n "$line" -f
    else
      echo "Skipping $line"
    fi
  done
fi
----

=== Verify the app, zero downtime
